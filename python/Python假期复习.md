# Python复习

## 1、python核心

### 1.1 Python运行机制

1、python是如何运行的？

```python
Python程序在运行时，会先进行编译，将.py文件中的代码编译成字节码，编译结果存储在内存的PyCodeObject中，然后由Python虚拟机解释运行，当程序运行结束后,Python解释器会将PyCodeObject保存到pyc文件中，每一次运行时Python都会先寻找与文件同名的.pyc文件，若pyc文件存在则对比修改记录，根据修改记录决定直接运行或再次进行编译后执行，最后生成.pyc文件
```

2、编译和解释型语言的区别？

```python
编译：在程序运行之前，通过编译器将源代码变成机器码，例如：C语言。
-- 优点：运行速度快
-- 缺点：开发效率低，不能跨平台。

解释：在程序运行之时，通过解释器对程序逐行翻译，然后执行。例如Javascript
-- 优点：开发效率高，可以跨平台；
-- 缺点：运行速度慢。
```

3、python运行慢的原因有哪些？有哪些对应的解决方法？

```
python是强类型语言，所以解释器运行时遇到变量以及数据类型转换、比较操作、引用变量时都需要检查其数据类型
python的编译器启动速度比Java快，但几乎每次都要进行编译
python的对象模型会导致内存访问效率变低，Numpy的指针指向缓存区数据的值，而python的指针指向缓存对象，再通过缓存对象指向数据

对应的解决方案：
1、可以使用其他的解释器，例如PyPy和Jython
2、如果对性能要求较高且静态类型变量较多的Python程序，可以使用Cpython
对于I/O操作多的应用程序，Python提供asyncio模块提高异步能力
```

4、.py文件与.pyc文件的不同之处

```
虽然这两种文件均保存字节代码，但.pyc文件时Python文件的编译版本，它是与平台无关的字节代码，因此可以在任何支持.pyc格式文件的平台上执行它，Python会自动生成它以优化性能（加载时间，而非运行速度）
```

5、python的解释器有哪些？它们的特点有哪些？

```python
CPython是官方版本的解释器，因为CPython是使用C语言开发的，所以叫CPython,在命令行运行Python就是启动CPython解释器
IPython是基于CPython之上的一个交互式解释器，也就是说IPython只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的
PyPy是有Python写的解释器，其执行速度是最快的。PyPy采用JIT技术，对python代码进行动态编译（不是解释）
Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行
IronPython和Jython类似，只不过IronPython是运行在.Net平台上Python解释器代码编译成.Net的字节码。
```

6、什么是Python自省

```python
自省是指这种能力：检查某些事物以确定它是什么，它知道什么以及它能做什么。Python自省是Python具有的一种能力，使用面向对象的语言所写的程序在运行时，所能知道对象的类型，即运行时获得对象的类型。
```

常用的自省函数？

```
help() 用来查看很多python自带的帮助文档信息
dir() 可以列出对象的所有属性
type() 返回对象的类型
id() 返回对象的"唯一序号"，对于引用的对象来说，返回地是被引用的对象的id
isinstance() 可以确定某个变量是否有某种类型
hasattr()和getattr() 分别判断对象是否有某个属性及某个属性值
callable()判断对象是否可以被调用
```

7、什么是python,使用python有什么好处

```python
python是一个免费、开源、跨平台、动态、面向对象的编程语言。
python具有以下一个特点：
	Python是一种解释性语言，因此，Python代码在运行之前不需要编译
	Python是动态类型语言，在声明变量时，不需要指定变量的类型
    Python是面向对象的设计语言，它支持通过组合和继承的方式定义类
    编写Python代码比较容易，但是运行速度比编译语言要慢
    Python常被用做胶水语言，可帮助其他语言和组件改善运行状况
    程序员使用Python可以专注于算法和数据结构的设计，而不用处理底层的细节
```

8、python2和3的区别有哪些？

| 类别              | python2                                                      | python3                                                      |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| print函数         | 使用print语句                                                | print语句没有了，使用print()函数                             |
| Unicode           | ASCII编码                                                    | UTF-8编码                                                    |
| 除法运算          | / 结果是一个整数商                                           | / 结果是正确的结果                                           |
| 异常              | 捕获异常语法由execpt exc,var                                 | 捕获异常语法由execpt exc as var                              |
| xrange()函数      | xrange()可以生成序列                                         | 取消xrange()函数，使用range()函数                            |
| 八进制字面表示    | 不能使用01000                                                | 八进制字面量表示只有0o1000                                   |
| 不等运算符        | ！=和<>                                                      | !=                                                           |
| repr表达式        | ``相当于repr函数的作用                                       | 只允许使用repr函数                                           |
| 数据类型          | long,int                                                     | 只有int（包含了long）范围增加                                |
| input和raw_input  | raw_input将输入的数据当作字符串看待，input输入必须是合法的表达式 | input（）函数                                                |
| 缩进              | 1个tab和8个space是等价的，可以同时存在                       | 不能同时存在，单独可以使用                                   |
| 打开文件          | file()或者open()                                             | open()                                                       |
| map,filter,reduce | 内置函数，输出结果都是列表                                   | 从函数变成了类，结果从列表变成了可迭代对象，可以用next函数来进行手工迭代 |

9、什么是变量，变量的命名规范

```python
1.	定义：关联一个对象的标识符。
2.	命名规范:
	1、必须是字母或下划线开头，后跟字母、数字、下划线。
    2、变量名不允许含有空格，但是可以用下划线来分割单词
    3、不能将Python中的关键字和函数名作为变量名，关键字是Python特殊用途的单词
    4、变量名最好见名知意
    5、避免使用大写字母
```

### 1.2、数据类型

1、Python都要哪些自带的数据类型？可变类型与不可变类型分别包括哪些？

```python
可变数据类型表示允许变量的值发生变化，如果改变了该数据类型的对应的值，那么不会重新分配内存空间，即如果对变量进行append或+=等操作后，只是改变了变量的值，而不会创建一个对象变量引用的对象的内存地址也不会发生变化，对于相同的值的不同对象，在内存中则会存在不同的对象，每个对象都有自己的地址，相当于内存中对于相同值的对象保存了多份，这里不存在引用计数，是实实在在的对象，可变的数据类型包括：列表，集合，和字典
不可变数据类型表示不允许变量的值发生变化，如果改变了该数据类型的对应变量的值，那么会重新分配内存空间，相当于重新创建了一个对象，不可变数据类型包括：字符串，元组和数值
```

```python
可变对象
	例如:列表，集合，字典
        特点：预留空间，自动扩容，动态改变
        自动扩容：
        	1、开辟更大空间
            2、拷贝原始数据
            3、替换引用（地址）
        优点：
        	动态添加数据
        缺点：
        	原始数据成为垃圾
        解决：
        	预留空间
不可变对象
	例如：数值，字符串，元组，bool
    	特点：按需分配（省内存）
存储多个数据：优先选择元组，因为性能更高，如果需要修改，再使用列表
```

2、列表、元组、集合、字典的区别有哪些？

| 列表、元组、集合、字典的区别 |                                |                                  |                                  |                                  |
| ---------------------------- | ------------------------------ | -------------------------------- | -------------------------------- | -------------------------------- |
|                              | 列表                           | 元组                             | 集合                             | 字典                             |
| 英文                         | list                           | tuple                            | set                              | dict                             |
| 定义                         | 由一系列变量组成的可变序列容器 | 由一系列变量组成的不可变序列容器 | 由一系列键值对组成的可变散列容器 | 由一系列键值对组成的可变散列容器 |
| 可否读写                     | 读写                           | 只读                             | 读写                             | 读写                             |
| 可否重复                     | 是                             | 是                               | 否                               | 是                               |
| 存储方式                     | 值                             | 值                               | 键（不能重复，自动去重）         | 键值对（键不能重复）             |
| 是否有序                     | 有序                           | 有序                             | 无序                             | 无序，自动正序                   |

具体用法及方法详见思维导图总结

3、什么是深拷贝与浅拷贝，区别是什么？

```python
浅拷贝：复制过程中,只复制一层变量,不会复制深层变量绑定的对象的复制过程。
深拷贝：复制整个依懒的变量。
```

4、自定义排序算法(降序)

```python
list01 = [1,3,4,2,7,0]
for r in range(len(list01)-1):
    for c in range(r+1,len(list01)):
        if list01[r]<list01[c]:
            list01[r],list01[c] = list01[c],list01[r]
```

5、连接字符串用join还是+？

```python
当用操作符+连接字符的时候，每执行一次都会申请一块新的内存，然后复制上一个+操作的结果和本次操作的有操作符到这块内存空间，因此+连接字符串的时候会涉及好几次内存申请和复制，而join在连接字符串的时候，会先计算多大的内存存放结果，然后一次性申请所需内存并将字符串复制过去，这就是为什么join的性能优于+的原因，
```

6、datetime模块

datetime模块提供了以下几个类：
	datetime:包含时间和日期
	date:只包含日期
	time:只包含时间
	timedelta:计算时间跨度
	tzinfo:时区信息

```python
datetime类
datetime.today():返回当前本地日期和时间
datetime.now(tz=None):返回本地当前的日期和时间，如果参数是None或未指定，则等同于today()
datetime.ntcnow():返回当前UTC日期和时间
datetime.fromtimestamp(timestamp,tz=None):返回与UNIX时间戳对应的本地日期和时间
datetime.utcfromtimestamp(timestamp,tz=None):返回与UNIX时间戳对应的本地日期和时间
    
date类
date.today():返回当前本地日期
date.fromtimestamp(timestamp,tz=None):返回与UNIX时间戳对应的本地日期

time类
datetime.time(hour=0,minute=0,second=0,microsecond=0,tzinfo=None)

timedelta类
import datetime
datetime.date.today()
delta = datetime.timedelta(10)
d += delta
print(d)
```

7、time模块

```python
import time

# 1. 时间元组(人类时间)： 公园元年 ～ 现在(2020年8月18日)
time_tuple = time.localtime()
# 年 月 日 时 分 秒 星期(索引) 一年的第几天  夏令时
print(time_tuple)

print(time_tuple[3])  # 获取小时

# 2. 时间戳(计算机时间): 公园1970年元旦现在经过的秒数
print(time.time())  # 1597739927.6006446
print(time.ctime())

# 3. 时间元组 ----> 时间戳
# 时间戳 = time.mktime(时间元组)
print(time.mktime(time_tuple))

# 4. 时间戳 ----> 时间元组
# 时间元组 = time.localtime(时间戳)
print(time.localtime(1597739927.6006446))

# 5. 时间元组  --> 字符串
# 2020/08/18 16:53:46
#  字符串 = time.strftime(格式,时间元组)
print(time.strftime("%Y/%m/%d %H:%M:%S", time_tuple))

# 6.  字符串 -->时间元组
print(time.strptime("2020/08/18 16:53:46", "%Y/%m/%d %H:%M:%S")
```

### 1.3、函数

1、Python如何定义一个函数？

```python
函数代码块以def关键字开头，后接函数标识符名称和圆括号
任何传入参数和自变量必须放在圆括号中间，圆括号中间可以用于定义参数
函数的第一行语句可以选择性的使用文档字符串，用于存放函数说明
函数内容以冒号起始，并且缩进
return表达式用于结束函数，选择性的返回一个值给调用者，不带return默认返回None
默认情况下，参数值和参数名称是按照函数声明中定义的顺序来匹配的
```

2、函数参数有哪些?

```python
实际参数：与形参对应
	位置实参：按顺序
    	函数名称（数据1，数据2，数据3）
    关键字实参：按名称
    	函数名称（形参名1=数据1，形参名2=数据2）
    序列实参：拆
    	函数名称（*序列）
    字典实参：拆
    	函数名称（**字典）
形式参数：规定实参
	默认形参：实参可选
    	def 函数名（形参名1=数据1，形参名2=数据2）
    位置形参：实参必填
    	def 函数名（形参名1，形参名2）
    命名关键字形参：必须是关键字实参
    	def 函数名（*args,形参名1，形参名2）
        def 函数名（*，形参名1，形参名2）
    星号元组形参：位置实参数量无限，合
		def 函数名称（*args）
    双星号字典形参：关键字实参数量无限，合
    	def 函数名称（**kwargs）
***传入可变 修改可变 无需return***
```

3、作用域

```python
1.	作用域：变量起作用的范围。
2.	Local局部作用域：函数内部。
3.	Enclosing  外部嵌套作用域 ：函数嵌套。 
4.	Global全局作用域：模块(.py文件)内部。 
5.	Builtin内置模块作用域：builtins.py文件。
python在函数里面的查找分为4种，称之为LEGB，也正是按照这是顺序来查找的
```

4、什么是lambda函数？ 有什么好处？

```python
lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数
1.lambda函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下
2.匿名函数，一般用来给filter，map这样的函数式编程服务
3.作为回调函数，传递给某些应用，比如消息处理
```

5、普通函数和lambda函数有什么异同点？

```python
相同点：
	都可以定义固定的方法和程序处理流程
	都可以包含参数
不同点：
	lambda函数代码更简洁，但是def定义的普通函数更为直观，容易理解
	def定义的是普通函数，而lambda定义的是表达式
	lambda函数不能包含分支或者循环，不能包含return语句
	关键字lanbda用来创建匿名函数，而关键字def用来创建有名称的普通函数
```

6、python的函数参数传递方式是什么？

```
值传递指的是在调用函数时，将实际参数复制一份传递给形式参数，这样在函数中可以修改形式参数，而不会影响到实际参数，引用传递指的是，在调用函数时，将实际参数的地址传递给函数，这样在函数中对参数的修改将会直接影响到实际参数，对于不可变数据类型来说，可以认为函数的参数传递时值传递，而对于可变数据类型来说，函数的参数传递时引用传递
```

7、编写函数的4个原则

```python
1.函数设计要尽量短小
2.函数声明要做到合理、简单、易于使用
3.函数参数设计应该考虑向下兼容
4.一个函数只做一件事情，尽量保证函数语句粒度的一致性
```



## 2、面向对象

1、什么是面向对象

```
面向对象是相对于面向过程而言的，面向对象是一种编程思想，是以类的眼光来看待事物的一种方式，面向过程语言是一种基于功能分析的，以算法为中心的程序设计方法；而面向对象是一种基于结构分析的，以数据为中心的程序设计思想，面向对象由封装继承和多态三种特性
```

2、三大特征和六大原则

```python
三大特征：
	封装（分）：
		数据角度讲：将一些基本数据类型复合成一个自定义类型
		行为角度讲：向类外提供必要的功能，隐藏实现的细节
		设计角度讲：
			分而治之：将一个大的需求分解为许多类，每个类处理一个独立的功能，每个类完成一项独立的发功能
			变则疏之：变化的地方独立封装，避免影响其他类。数据不同用实例封装，行为不同，用类来封装
			高内聚：类中各个方法都在完成一项任务(单一职责的类)，每个类都在独立完成单一的一件事情
			低耦合：类与类的关联性与依赖度要低(每个类独立)，让一个类的改变，尽少影响其他类
	继承（隔离变化）：
		语法角度将：继承方法。继承数据
		设计角度讲：将相关类的共性进行抽象，统一概念，隔离变化
	多态（做）：
		设计角度讲：父类的同一种动作或者行为，在不同的子类上有不同的实现；多态的发生要有两个前提条件，第一，继承-多态一定发生在子类与父类之间；第二，		   重写—子类重写了父类的方法
		语法角度讲：子类实现了父类中相同的方法（方法名、参数）。在调用该方法时，实际执行的是子类的方法。
六大原则：
	开闭原则（总的指导思想）：
		Open Closed Principle
		对扩展开放，对修改关闭。
		增加新功能，不改变原有代码。
	类的单一职责：
		Single Responsibility Principle   
		一个类有且只有一个改变它的原因。
	依赖倒置（依赖抽象）：
		Dependency Inversion Principle
		客户端代码(调用的类)尽量依赖(使用)抽象。
		抽象不应该依赖细节，细节应该依赖抽象。
	组合复用原则（复用的最佳实践）：
		Composite Reuse Principle
		如果仅仅为了代码复用优先选择组合复用，而非继承复用。是作为参数传递，是一种拥有的关系，而非是的关系
	里氏替换（继承后的重写，指导继承的设计）：
		Liskov Substitution Principle
		父类出现的地方可以被子类替换，在替换后依然保持原功能。
		子类要拥有父类的所有功能。
		子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。
	迪米特法则（类与类交互的原则）：
		Law of Demeter
		不要和陌生人说话。
		类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。
```

3、python新式类和经典类的区别？

```python
a. 在python里凡是继承了object的类，都是新式类
b. Python3里只有新式类
c. Python2里面继承object的是新式类，没有写父类的是经典类
d. 经典类目前在Python里基本没有应用
e. 保持class与type的统一对新式类的实例执行a.class与type(a)的结果是一致的，对于旧式类来说就不
一样了。
f.对于多重继承的属性搜索顺序不一样新式类是采用广度优先搜索，旧式类采用深度优先搜索。
```

4、Python中类方法、类实例方法、静态方法有何区别？

```
类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用
类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身
静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系
```

5、self表示什么含义？

```python
self表示当前对象，本质上存放的是当前对象的地址，那个对象调用这个成员方法，那么self就指向这个对象，如果方法中由其他参数，那么直接写在self后面。
self只有在类的方法中才有，其他函数或者方法不必带self
在调用时不必传入相应的参数
在类的方法中，第一个参数永远是self
self不是python的关键字，也可以用其他名称命名，但是为了规范和便于读者理解，推荐使用self
如果不加self,表示类的一个属性，加了self表示类的实例的一个属性
```

6、__init__ 方法的作用是什么？

```python
类定义了__init__方法，类的实例化操作会自动调用__init__（）方法，这个初始化方法，会在对象创建后，而且是返回给调用者之前自动调用，通过该方法，可以对对象的属性进行初始化，也可以调用其他的方法，注意该方法只能返回None,不能返回其他数据类型
```

7、new和init的区别有哪些?

```
用法不同：
	new在init之前被调用，用于创建实例，是类级别的方法，是静态方法，如果new创建的是当前类的实例，那么会自动调用init函数，通过return调用的new的参数cls	 来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的init函数，init用于初始化实例，那么该方法是在实例对象创建后被	  调用，它是实例级的方法，用于设置对象属性的一些初始值
传入参数不同：
	new至少有一个参数cls,代表当前类，此参数在实例化时由python解释器自动识别，init至少有一个参数self，就是这个new返回的实例，init在new的基础上完成一	   些初始化的操作
返回值不同：
	new必须有返回值，返回实例对象，init不需要返回值，只有在new返回一个新创建属于该类的实例时当前类的init才会被调用
```

## 3、python高级

1、迭代对象，迭代器，生成器：

```python
"""
容器（container）
"""
# 容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。
# 通常这类数据结构把所有的元素存储在内存中（并不是所有的元素都放在内存中，比如迭代器和生成器对象）
# 尽管绝大多数容器提供了某种方式来获取其中的每一个元素，但这并不是容器本身，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的
# 从技术角度讲当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为时一个容器
"""
可迭代对象(iterable)
"""
# 刚才说过，很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，但凡可以返回一个迭代器的对象都可称之为可迭代对象
x = [1, 2, 3]
y = x.__iter__()  # y=iter(x)
z = x.__iter__()  # z=iter(x)
print(next(y))
print(next(y))
print(type(x))
print(type(y))
# 这里X时一个可迭代对象，可迭代对象和容器一样时一种通俗的叫法，并不是指某种具体的数据类型，List是可迭代对象，dict是可迭代对象，y和z是两个独立的迭代器
# 迭代器内部持有一个状态，该状态记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素，迭代器有一种具体的迭代器类型，比如list_iterator,set_iterator
# 可迭代对象实现了__iter__方法，该方法返回一个迭代器对象
"""
迭代器对象（iterator）
"""
# 迭代器，它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__方法的对象都是迭代器对象，__iter__返回迭代器自身
# __next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration
# 所以迭代器实现了工厂模式的对象，它在你每次询问要下一个值的时候给你返回
class Fib:
    def __init__(self, n=10):  # 初始化
        self.prev = 0
        self.curr = 1
        self.n = n

    def __iter__(self):  # 调用__iter__方法返回迭代器对象，返回自身，自身就是迭代器对象
        return self

    def __next__(self):  # 调用__next__方法返回下一个值
        self.prev, self.curr = self.curr, self.curr + self.prev
        if self.prev > self.n:
            raise StopIteration
        return self.prev


# f = Fib(20)
# for i in f:
#     print(i)
#Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法），实例变量prev,curr用户维护迭代器内部的状态
#每次调用next()方法的时候做两件事：
#1、为下一次调用next()方法修改状态  2、为当前这次调用生成返回结果
"""
生成器
"""
# 生成器是一种特殊的迭代器，只需要一个yield关键字,生成器一定是迭代器，反之不成立
def fibs():
    prev,curr=0,1
    while curr<10:
        yield curr
        prev,curr=curr,prev+curr
f=fibs()
for i in f:
    print(i)
"""
总结
"""
#1、容器时一系列元素的集合，容器都可以被迭代，因此它们都被称为可迭代对象
#2、可迭代对象实现了__iter__方法，该方法返回一个迭代器对象
#3、迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__iter__和__next__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果
#4、生成器是一种特殊的迭代器，他的返回值不是通过return而是通过yield
```

2、什么是模块？

```python
定义：包含一系列数据、函数、类的文件，通常以.py结尾。
作用：让一些相关的数据，函数，类有逻辑的组织在一起，使逻辑结构更加清晰。
```

3、模块的导入方式有哪些？

import

```python
1.语法： 
	import 模块名
	import 模块名 as 别名
2.作用：将某模块整体导入到当前模块中
3.使用：模块名.成员
```

from import

```python
1.语法：
	from 模块名 import 成员名[ as 别名1]
2.作用：将模块内的一个或多个成员导入到当前模块的作用域中。
3.使用：直接使用成员名
```

from module import *

```python
1.语法：from 模块名 import *
2.作用：将某模块的所有成员导入到当前模块。
```

4、什么是模块变量

```python
__doc__变量：文档字符串。
__name__变量：模块自身名字，可以判断是否为主模块。
当此模块作为主模块(第一个运行的模块)运行时，__name__绑定'__main__'，不是主模块，而是被其它模块导入时,存储模块名。
```

5、模块的分类？

```python
1.内置模块(builtins)，在解析器的内部可以直接使用。
2.标准库模块，安装Python时已安装且可直接使用。
3.第三方模块（通常为开源），需要自己安装。
4.用户自己编写的模块（可以作为其他人的第三方模块）
```

6、什么是包？

```python
定义：将模块以文件夹的形式进行分组管理
作用：将模块以文件形式进行分组管理
__init__.py 文件：
	是包内必须存在的文件
	会在包加载时被自动调用
	记录import 包 语句需要导入的模块
	__all__可以记录from 包 import * 语句需要导入的模块
    __all__=["func01"]

存储路径：项目根目录->包->模块->类->函数->语句
```

7、搜索顺序

```python
导入模块是否成功的唯一标准：
	导入路径+系统路径=真实路径
```

8、什么是异常？

```python
1.定义：运行时检测到的错误。
2.现象：当异常发生时，程序不会再向下执行，而转到函数的调用语句。
3.常见异常类型：
-- 名称异常(NameError)：变量未定义。
-- 类型异常(TypeError)：不同类型数据进行运算。
-- 索引异常(IndexError)：超出索引范围。
-- 属性异常(AttributeError)：对象没有对应名称的属性。
-- 键异常(KeyError)：没有对应名称的键。
-- 异常基类Exception。
```

9、异常处理

```python
目标：不是针对代码写错进行处理，而是针对运行时，数据操作有效范围而引发的错误
现象：程序不再向下执行，不断向上返回，直到最初的调用语句
作用：将异常状态改为正常状态
价值：保证程序按照既定流程处理
```

10、异常的几种写法？

```python
# 写法1:"包治百病"
def div_apple(apple_count):
    try:
        # ValueError
        person_count = int(input("请输入人数："))
        # ZeroDivisionError
        result = apple_count / person_count
        print(f"每人{result}个苹果")
    except Exception:
        print("程序出错啦")
        
# 写法2:"对症下药" (官方推荐)
def div_apple(apple_count):
    try:
        # ValueError
        person_count = int(input("请输入人数："))
        # ZeroDivisionError
        result = apple_count / person_count
        print(f"每人{result}个苹果")
    except ValueError:
        print("输入的不是整数")
    except ZeroDivisionError:
        print("输入的是0")
   
# 写法3:不管是否错误或哪种错误,一定执行某些逻辑.
def div_apple(apple_count):
    try:
        # 打开文件
        # 处理...
        
        # ValueError
        person_count = int(input("请输入人数："))
        # ZeroDivisionError
        result = apple_count / person_count
        print(f"每人{result}个苹果")
    except ValueError:
        print("输入的不是整数")
    finally:# 无论对错一定执行的代码
        # 关闭文件
        print("游戏结束")

# 写法4:程序没有错误,执行的逻辑.
def div_apple(apple_count):
    try:
        person_count = int(input("请输入人数：")) 
        result = apple_count / person_count
        print(f"每人{result}个苹果")
    except Exception:
        print("程序出错啦")
    else:
        print("游戏胜利")
```

11、什么是函数式编程，主要思想是什么？

```python
函数式编程思想：
	分：将变化点单独定义到函数中
	隔：用参数在不变的代码中，调用变化的函数
	做：以参数调用的方式为规定，制作变化函数
实用性：
	好多相似的代码，但核心算法不同
参数：
	传递列表视为数据灵活
	传递函数视为逻辑灵活
```

12、python中的高阶函数

```python
map（函数，可迭代对象）：使用可迭代对象中的每个元素调用函数，将返回值作为新可迭代对象元素；返回值为新可迭代对象。
filter(函数，可迭代对象)：根据条件筛选可迭代对象中的元素，返回值为新可迭代对象。
sorted(可迭代对象，key = 函数,reverse = bool值)：排序，返回值为排序结果。
max(可迭代对象，key = 函数)：根据函数获取可迭代对象的最大值。
min(可迭代对象，key = 函数)：根据函数获取可迭代对象的最小值。
```

13、解释一下什么是闭包？有什么作用？

```python
内部函数可以引用外部函数的参数和局部变量，当外部函数返回内部函数时，相关参数和变量都保存在返回的函数中，这种特性称之为"闭包"，闭包是两个函数的嵌套，外部函数返回内部函数的引用，外部函数一定要有参数
闭包：
   字面意思：
       封闭   内存空间
   作用：
       让外部函数栈帧调用结束后不释放
       给内部函数使用
   三大要素
       有外有内
       内访问外
       外返回内
1、三要素：
	-- 必须有一个内嵌函数。
	-- 内嵌函数必须引用外部函数中变量。
	-- 外部函数返回值必须是内嵌函数
2、语法：
	def func01():
    a = 10

    def func02():
        print(a)

    # 返回内部函数,没有调用内部函数.
    return func02

# 调用外部函数,结果是内部函数
result = func01()
# 调用内部函数
result()
result()
3.定义：是由函数及其相关的引用环境组合而成的实体。
4.优点：内部函数可以使用外部变量。
5.缺点：外部变量一直存在于内存中，不会在调用结束后释放，占用内存。
6.作用：实现python装饰器。
```

14、什么是函数装饰器？

```python
1.定义：在不改变原函数的调用以及内部代码情况下，为其添加新功能的函数。
2.语法：
	def 函数装饰器名称(func):
        def wrapper(*args, **kwargs):
            需要添加的新功能
            return func(*args, **kwargs)
    return wrapper

	   		原函数 = 内嵌函数
		@ 函数装饰器名称
		def 原函数名称(参数):
			函数体

		原函数(参数)   
3.本质：使用“@函数装饰器名称”修饰原函数，等同于创建与原函数名称相同的变量，关联内嵌函数；故调用原函数时执行内嵌函数。
原函数名称 = 函数装饰器名称（原函数名称）
4.装饰器链：一个函数可以被多个装饰器修饰，执行顺序为从近到远。
```

```python
装饰器：
	不改变原函数，增加新功能
	有内有外：外在接收旧功能，内在包裹旧与新功能，
    外函数包含内函数
	def print_execution_time(func):
	内访问外：新功能执行的同时执行旧功能
    内部函数引用外部函数中变量，实际是旧功能函数名作为参数传递进来
        def wrapper(*args, **kwargs):
        start = time.time()
        # 执行旧功能
        result = func(*args, **kwargs)
        stop = time.time()
        print(f"执行时间是：{stop - start}")
        return result
    外返回内：让其他代码重复使用内部函数
    外部函数返回内部函数名
    return wrapper
```

15、为一个程序加上计时功能

```python
import time


def print_execution_time(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        # 执行旧功能
        result = func(*args, **kwargs)
        stop = time.time()
        print(f"执行时间是：{stop - start}")
        return result

    return wrapper


@print_execution_time
def sum_data(n):
    sum_value = 0
    for number in range(n):
        sum_value += number
    return sum_value


print(sum_data(10))
print(sum_data(1000000))
```

## 4、Linux操作系统

详见思维导图

## 5、文件

1、读文件

```python
read([size])
功能： 来直接读取文件中字符。
参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size最多读取给定数目个字符（字节）。
返回值： 返回读取到的内容

readline([size])
功能： 用来读取文件中一行
参数： 如果没有给定size参数（默认值为-1）或者size值为负，表示读取一行，给定size表示最多读取制定的字符（字节）。
返回值： 返回读取到的内容

readlines([sizeint])
功能： 读取文件中的每一行作为列表中的一项
参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size表示读取到size字符所在行为止。
返回值： 返回读取到的内容列表

# 文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。
for line in f:
     print(line)
```

2、写文件

```
write(data)
功能: 把文本数据或二进制数据块的字符串写入到文件中去
参数：要写入的内容
返回值：写入的字符个数

writelines(str_list)
功能：接受一个字符串列表作为参数，将它们写入文件。
参数: 要写入的内容列表
```

3、关闭文件

```
file_object.close()

with open('file','r+') as f:
    f.read()
```

4、缓冲区

```
系统自定义 buffering=-1
行缓冲 buffering=1 当遇到\n时刷新缓冲
指定缓冲区大小 buffering>1 必须以二进制方式打开

刷新缓冲区条件
1. 缓冲区被写满
2. 程序执行结束或者文件对象被关闭
3. 程序中调用flush()函数
```

5、文件偏移量

```
定义：
打开一个文件进行操作时系统会自动生成一个记录，记录每次读写操作时所处的文件位置，每次文件的读写操作都是从这个位置开始进行的。

文件偏移量控制：
tell()
功能：获取文件偏移量大小
返回值：文件偏移量

seek(offset[,whence])
功能: 移动文件偏移量位置
参数：offset  代表相对于某个位置移动的字节数。负数表示向前移动，正数表示向后移动。
     whence是基准位置的默认值为 0，代表从文件开头算起，1代表从当前位置算起，2 代表从文件  末尾算起。

```

```python
"""
重点代码 !!

编写一个 函数 传入一个 图片,将该图片复制到
程序所在的文件夹下面，以当前日期命名保存

思路 ：　从源文件搞出内容，写入到新文件里边
　　　　* 如果文件比较大，循环的读写比较好？
       * 循环读写时候什么时候结束？
"""
import time

def copy(filename):
    """
    :param filename: 要拷贝的文件
    """
    fr = open(filename,'rb') # 源文件
    # 写文件
    file = "%s-%s-%s.jpg"%time.localtime()[:3]
    fw = open(file,'wb')
    # 一边读 一边写
    while True:
        data = fr.read(1024)
        if not data:
            break
        fw.write(data)
    fr.close()
    fw.close()

copy("./timg.jpg")
```

6、os模块

```python
os.path.getsize(file)
功能： 获取文件大小
参数： 指定文件
返回值： 文件大小

os.listdir(dir)
功能： 查看文件列表
参数： 指定目录
返回值：目录中的文件名列表

os.path.exists(file)
功能： 查看文件是否存在 
参数： 指定文件
返回值：存在返回True，不存在返回False

os.path.isfile(file)
功能： 判断文件类型 
参数： 指定文件
返回值：普通文件返回True，否则返回False

os.remove(file)
功能： 删除文件 
参数： 指定文件
```

## 6、正则表达式

7、正则表达式

```
* 普通字符
匹配规则：每个普通字符匹配其对应的字符

元字符: `|` 
匹配规则: 匹配 | 两侧任意的正则表达式即可

元字符：`.`
匹配规则：匹配除换行外的任意一个字符

元字符： `[字符集]`
匹配规则: 匹配字符集中的任意一个字符

元字符：`[^字符集]`
匹配规则：匹配除了字符集以外的任意一个字符

元字符: `^`
匹配规则：匹配目标字符串的开头位置

元字符:  `$`
匹配规则: 匹配目标字符串的结尾位置

元字符: `*`
匹配规则：匹配前面的字符出现0次或多次

元字符：`+`
匹配规则： 匹配前面的字符出现1次或多次

元字符：`?`
匹配规则： 匹配前面的字符出现0次或1次

元字符：`{n}`
匹配规则： 匹配前面的字符出现n次

元字符：`{m,n}`
匹配规则： 匹配前面的字符出现m-n次

元字符： `\d`   `\D`
匹配规则：`\d` 匹配任意数字字符，`\D` 匹配任意非数字字符

元字符： `\w`   `\W`
匹配规则: `\w` 匹配普通字符，`\W` 匹配非普通字符
说明: 普通字符指数字，字母，下划线，汉字。

元字符： `\s`   `\S`
匹配规则:` \s`匹配空字符，`\S` 匹配非空字符
说明：空字符指 空格` \r \n \t \v \f` 字符

元字符：` \b`   `\B`
匹配规则：` \b` 表示单词边界，`\B` 表示非单词边界
说明：单词边界指数字字母(汉字)下划线与其他字符的交界位置。
```

8、re基础函数

```
 re.findall(pattern,string,flags = 0)
 功能: 根据正则表达式匹配目标字符串内容
 参数: pattern  正则表达式
      string 目标字符串
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 匹配到的内容列表,如果正则表达式有子组则只能获取到子组对应的内容
 
  re.split(pattern,string,max，flags = 0)
 功能: 使用正则表达式匹配内容,切割目标字符串
 参数: pattern  正则表达式
      string 目标字符串
      max 最多切割几部分
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 切割后的内容列表
 
 re.sub(pattern,replace,string,count,flags = 0)
 功能: 使用一个字符串替换正则表达式匹配到的内容
 参数: pattern  正则表达式
      replace  替换的字符串
      string 目标字符串
      count  最多替换几处,默认替换全部
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 替换后的字符串
 
  re.finditer(pattern,string,flags = 0)
 功能: 根据正则表达式匹配目标字符串内容
 参数: pattern  正则表达式
      string 目标字符串
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 匹配结果的迭代器
 
 re.match(pattern,string,flags=0)
功能：匹配某个目标字符串开始位置
参数：pattern 正则
	string  目标字符串
返回值：匹配内容match object

re.search(pattern,string,flags=0)
功能：匹配目标字符串第一个符合内容
参数：pattern 正则
	string  目标字符串
返回值：匹配内容match object
```

## 7、数据库

9、数据库分类和常见数据库

```
关系型数据库和非关系型数据库：
	关系型： 采用关系模型（二维表）来组织数据结构的数据库 
	非关系型： 不采用关系模型组织数据结构的数据库
	
开源和非开源
开源：MySQL、SQLite、MongoDB
非开源：Oracle、DB2、SQL_Server
```

10、什么是事务？

```
数据库中的事务是指对数据库执行一批操作，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。
```

11、事务的几个特性(ACID)

```
原子性(Atomicity)
事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。

一致性(Consistency)
一个事务必须使数据库从一个一致性状态变换到另一个一致性状态。
首先回顾一下一致性的定义。所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。

隔离性(Isolation)
一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

持久性(Durability)
一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。
```

12、隐式事务？

```
事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。
```

13、显式事务？

```
事务需要手动开启、提交或回滚，由开发者自己控制。
```

14、什么是脏读？不可重复读？幻读？

```
脏读：一个事务读取了已被另一个事务修改、但尚未提交的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时另外一个并发的事务来访问该数据时，就会造成两个事务得到的数据不一致

不可重复读：在同一个事务中，同一个查询在TIME1时刻读取某一行，在TIME2时刻重新读取这一行数据的时候，发现这一行的数据已经发生修改，可能被更新，也可以被删除

幻读：在同一事务中，当同一查询多次执行的时候，由于其他插入操作的事务提交，会导致每次返回不同的结果集，幻读是事务非独立执行时发生的一种现象。
```

15、事务的四种隔离级别

```
读未提交：READ-UNCOMMITTED
在该隔离级别，所有事务都可以看到其他为提交事务的执行结果，即在未提交读级别，事务中的修改，即使没有提交，对其他事务也都是可见的，也被称为脏读

读已提交：READ-COMMITTED
一个事务只能看见已经提交事务所做的改变，换句话说，一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的

可重复读：REPEATABLE-READ
可重复读可以确保同一个事务，在多次读取同样的数据的时候，得到同样的结果，可重复读解决了脏读的问题，不过理论上，这会导致另一个棘手的问题，幻读。mysql数据库中的InnoDB存储引擎通过MVCC(多版本并发控制)机制解决了该问题，多版本只是解决不可重复读问题，而加上间隙锁（并发控制）才解决了幻读问题。

串行：SERIALIZABLE
通过强制事务排序，强制事务串行执行，使之不能相互冲突，从而解决幻读问题，在每个读的数据行上加上共享锁，可能导致大量的超时现象和锁竞争
```

16、什么是索引？

```
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。

**优缺点**
- 优点 ： 加快数据检索速度,提高查找效率
- 缺点 ：占用数据库物理存储空间，当对表中数据更新时,索引需要动态维护,降低数据写入效率
	1. 通常我们只在经常进行查询操作的字段上创建索引
	2. 对于数据量很少的表或者经常进行写操作而不是查询操作的表不适合创建索引
```

17、索引分类？

```
普通索引 ：字段值无约束,KEY标志为 MUL
唯一索引(unique) ：字段值不允许重复,但可为 NULL,KEY标志为 UNI
主键索引（PRI）：一个表中只能有一个主键字段, 主键字段不允许重复,且不能为NULL，KEY标志为PRI。通常设置记录编号字段id,能唯一锁定一条记录
```

18、表关联设计方式？

```
一对一关系：一张表的一条记录一定只能与另外一张表的一条记录进行对应，反之亦然。
一对多关系：一张表中有一条记录可以对应另外一张表中的多条记录；但是反过来，另外一张表的一条记录只能对应第一张表的一条记录，这种关系就是一对多或多对一
多对多关系：一对表中（A）的一条记录能够对应另外一张表（B）中的多条记录；同时B表中的一条记录也能对应A表中的多条记录
```

19、ER模型

```
实体:
	1、描述客观事物的概念
	2、表示方法 ：矩形框
	3、示例 ：一个人、一本书、一杯咖啡、一个学生
属性:
	实体具有的某种特性
	表示方法 ：椭圆形
	示例
 		学生属性 ：学号、姓名、年龄、性别、专业 ... 
 		感受属性 ：悲伤、喜悦、刺激、愤怒 ...
关系:
	1、实体之间的联系
	2、一对一关联(1:1)
	3、一对多关联(1:n)
	4、多对多关联(m:n) 
```

20、什么是视图？

```
视图是存储的查询语句,当调用的时候,产生结果集,视图充当的是虚拟表的角色。其实视图可以理解为一个表或多个表中导出来的表，作用和真实表一样，包含一系列带有行和列的数据 视图中，用户可以使用SELECT语句查询数据，也可以使用INSERT，UPDATE，DELETE修改记录，视图可以使用户操作方便，并保障数据库系统安全，如果原表改名或者删除则视图也失效。
```

21、函数和存储过程区别

```
1. 函数有且只有一个返回值，而存储过程不能有返回值。
2. 函数只能有输入参数，而存储过程可以有in,out,inout多个类型参数。
3. 存储过程中的语句功能更丰富，实现更复杂的业务逻辑，可以理解为一个按照预定步骤调用的执行过程，而函数中不能展示查询结果集语句，只是完成查询的工作后返回一个结果，功能针对性比较强。
4. 存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用。
```

22、数据库设计范式？

```
- 第一范式： 数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等组合的数据项。简单来说要求数据库中的表示二维表，每个数据元素不可再分。
例如： 在国内的话通常理解都是姓名是一个不可再拆分的单位，这时候就符合第一范式；但是在国外的话还要分为FIRST NAME和LAST NAME，这时候姓名这个字段就是还可以拆分为更小的单位的字段，就不符合第一范式了。

- 第二范式： 第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分，所有属性依赖于主属性。即选取一个能区分每个实体的属性或属性组，作为实体的唯一标识，每个属性都能被主属性筛选。其实简单理解要设置一个区分各个记录的主键就好了。

- 第三范式： 在第二范式的基础上属性不传递依赖，即每个属性不依赖其他非主属性。要求一个表中不包含已在其它表中包含的非主关键字信息。其实简单来说就是合理使用外键，使不同的表中不要有重复的字段就好了。
```

23、MySQL存储引擎

```
InnoDB：
	1. 支持行级锁,仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
	2. 支持外键、事务、事务回滚
	3. 表字段和索引同存储在一个文件中
		 1. 表名.frm ：表结构
 		 2. 表名.ibd : 表记录及索引文件
MyISAM：
	1. 支持表级锁,在锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则		读也不允许
	2.  表字段和索引分开存储
      	 1. 表名.frm ：表结构
         2. 表名.MYI : 索引文件(my index)
         3. 表名.MYD : 表记录(my data)
如何选择：
	1. 执行查操作多的表用 MyISAM(使用InnoDB浪费资源)
	2. 执行写操作多的表用 InnoDB
```

24、SQL优化

```
- 尽量选择数据类型占空间少，在where ，group by，order by中出现的频率高的字段建立索引

- 尽量避免使用 select * ...;用具体字段代替 * ,不要返回用不到的任何字段 

- 少使用like %查询，否则会全表扫描

- 控制使用自定义函数

- 单条查询最后添加 LIMIT 1，停止全表扫描

- where子句中不使用 != ,否则放弃索引全表扫描

- 尽量避免 NULL 值判断,否则放弃索引全表扫描

  优化前：select number from t1 where number is null;

  优化后：select number from t1 where number=0;

  * 在number列上设置默认值0,确保number列无NULL值

- 尽量避免 or 连接条件,否则会放弃索引进行全表扫描，可以用union代替

  优化前：select id from t1 where id=10 or id=20;

  优化后： select id from t1 where id=10 union all  select id from t1 where id=20;

- 尽量避免使用 in 和 not in,否则会全表扫描

  优化前：select id from t1 where id in(1,2,3,4);

  优化后：select id from t1 where id between 1 and 4;
```

## 8、并发网络编程

1、udp编程

```python
"""
udp 客户端
重点代码 ！！！
"""
from socket import *

# 服务器地址
ADDR = ("127.0.0.1",8888)

# 创建udp套接字
udp_socket = socket(AF_INET,SOCK_DGRAM)

# 发送后接收，与服务端配合
while True:
    msg = input(">>")
    # 直接回车退出，不用管服务器
    if not msg:
        break
    udp_socket.sendto(msg.encode(),ADDR) # 发送字节串
    # 输入exit结束循环
    # if msg == 'exit':
    #     break
    data,addr = udp_socket.recvfrom(1024)
    print("From server:",data.decode())

# 关闭套接字
udp_socket.close()
```

```python
"""
udp套接字服务端程序示例

重点代码 ！！！
"""
from socket import *

# 创建udp套接字
udp_socket = socket(AF_INET,SOCK_DGRAM)

# 绑定地址
udp_socket.bind(('0.0.0.0',8888))

# 接收消息
while True:
    data,addr = udp_socket.recvfrom(1024)
    # 收到exit结束 服务端程序可以一直运行
    # if data == b"exit":
    #     break

    print("From",addr,":",data.decode())
    # 发送消息
    n = udp_socket.sendto(b"Thanks",addr) # 发送字节串
    print("Send %d bytes"%n)

# 关闭套接字
udp_socket.close()
```

2、tcp三次握手和四次挥手是怎样的过程？

```python
三次握手（建立连接）
* 客户端向服务器发送消息报文请求连接
* 服务器收到请求后，回复报文确定可以连接
* 客户端收到回复，发送最终报文连接建立

四次挥手（断开连接）
* 主动方发送报文请求断开连接
* 被动方收到请求后，立即回复，表示准备断开
* 被动方准备就绪，再次发送报文表示可以断开
* 主动方收到确定，发送最终报文完成断开
```

3、tcp编程

```python
"""
tcp 服务端基础实例
重点代码 ！！
"""
from socket import *
import time

# 创建tcp套接字
tcp_socket = socket(AF_INET, SOCK_STREAM)
# 绑定地址
tcp_socket.bind(('0.0.0.0', 8888))
# 设置监听
tcp_socket.listen(5)
while True:
    # 处理客户端链接 (阻塞函数)
    print("Waiting for connect...")
    connfd, addr = tcp_socket.accept()
    print("Connect from", addr)
    # 收发消息
    while True:
        # 链接的另外一端结束 此时 recv会返回空字节串
        data = connfd.recv(5)
        # 收到##或者data为空字节串时 表示客户端结束
        if not data or data == b"##":
            break
        print("接收到：", data.decode())

        connfd.send(b"Thanks#")  # 设置消息边界
        time.sleep(0.1)

    connfd.close()

# 关闭套接字
tcp_socket.close()
-----------------------------------------------------------------------------------------------------------------------------------------
"""
tcp客户端示例2
多个客户端循环发送消息

重点代码！！
"""
from socket import *

# 循环发送消息
# 每次发送消息都需要重新建立套接字，发起链接，效率较低
while True:
    msg = input(">>")
    if not msg:
        break

    # 创建套接字，完成一次消息的收发后就关闭
    tcp_socket = socket()
    tcp_socket.connect(('127.0.0.1',8888))
    tcp_socket.send(msg.encode())
    data = tcp_socket.recv(1024)
    print("from Server：",data.decode())
    tcp_socket.close()
```

4、tcp套接字细节

```
tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。

tcp连接中如果一端已经不存在，仍然试图通过send向其发送数据则会产生BrokenPipeError

一个服务端可以同时连接多个客户端，也能够重复被连接

tcp粘包问题

产生原因：
为了解决数据再传输过程中可能产生的速度不协调问题，操作系统设置了缓冲区
实际网络工作过程比较复杂，导致消息收发速度不一致
tcp以字节流方式进行数据传输，在接收时不区分消息边界
```

5、tcp可靠数据传输原理

```
每个Tcp socket在内核中都有一个发送缓冲区和一个接受缓冲区。tcp协议要求对端在接受到tcp数据报之后，要对其序号进行ACK，只有当接受到一个tcp数据报的ACK之后，才可以把这个tcp数据报从socket的发送缓冲区清除，另外tcp还有一个流量控制功能，tcp的socket接受缓冲区接受到网络上来的数据缓存起来后，如果应用程序一直没有读取，
socket接受缓冲区满了之后，发生的动作是：通知对端TCP协议中的窗口关闭，这便是滑动窗口的实现，保证TCP socket接受缓冲区不会溢出，因为对方不允许发送超过所通知窗口大小的数据， 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。这两点保证了tcp是可靠传输的。
```

6、udp不可靠传输原理

```
UDP只有一个socket接受缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接受。而在对方的socket接受缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区，此数据报就会被丢弃，udp是没有流量控制的，故UDP的数据传输是不可靠的。
```

7、tcp与udp对比

```
传输特征
   TCP提供可靠的数据传输，但是UDP则不保证传输的可靠性
   TCP传输数据处理为字节流，而UDP处理为数据包形式
   TCP传输需要建立连接才能进行数据传，效率相对较低，UDP比较自由，无需连接，效率较高
套接字编程区别
   创建的套接字类型不同
   tcp套接字会有粘包，udp套接字有消息边界不会粘包
   tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要
   tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom
使用场景
   tcp更适合对准确性要求高，传输数据较大的场景
      文件传输：如下载电影，访问网页，上传照片
      邮件收发
      点对点数据传输：如点对点聊天，登录请求，远程访问，发红包
udp更适合对可靠性要求没有那么高，传输方式比较自由的场景
      视频流的传输： 如直播，视频聊天
      广播：如网络广播，群发消息
      实时传输：如游戏画面
在一个大型的项目中，可能既涉及到TCP网络又有UDP网络
```

8、什么是多任务及多任务编程？

```
多任务即操作系统中可以同时运行多个任务。比如我们可以同时挂着qq，听音乐，同时上网浏览网页。这是我们看得到的任务，在系统中还有很多系统任务在执行,现在的操作系统基本都是多任务操作系统，具备运行多任务的能力。
多任务编程即一个程序中编写多个任务，在程序运行时让这多个任务一起运行，而不是一个一个的顺次执行。
```

9、并行和并发有什么区别？

```
并发 ：多个任务如果被分配给了一个cpu内核，那么这多个任务之间就是并发关系，并发关系的多个任务之间并不是真正的‘"同时"。
并行 ：多个任务如果被分配给了不同的cpu内核，那么这多个任务之间执行时就是并行关系，并行关系的多个任务时真正的“同时”执行。
在任务中无阻塞时只有并行状态才能提高效率，在任务中有阻塞时并行并发都能提高效率
```

10、什么是进程线程与协程？

```
见进程线程协程详解
```

11、 多进程编程的流程是什么？

```python
"""
创建进程基础示例1
1.将需要新进程执行的事件封装为函数
2.通过模块的Process类创建进程对象，关联函数
3.通过进程对象调用start启动进程
4.通过进程对象调用join回收进程资源
"""
import multiprocessing
from time import sleep

a = 1
# 进程执行的函数
def fun():
    print("开始运行一个进程")
    sleep(2)
    global a
    print("a=",a)
    a = 1000
    print("进程执行结束了")
# 实例化进程对象
p = multiprocessing.Process(target=fun)
# 启动进程 ，自动执行target绑定的函数，进程诞生
p.start()
print("执行另外一个事情")
sleep(3)
print("事情干完了")


#阻塞等待进程结束后回收
p.join()
print("a=",a)
```

12、多线程编程的流程是什么？

```python
"""示例代码"""
import os
import threading
from time import sleep

a = 1


def music():
    for i in range(3):
        sleep(2)
        print(os.getpid(),"播放:葫芦娃")
    global a
    # 在一个函数中对全局变量进行修改的时候，到底是否需要使用global进行说明，要看是否对全局变量的执行指向进行了修改，如果修改了执行，即让全局变量指向	了一个新的地方，那么必须使用global，如果，仅仅是修改了指向的空间中的数据，此时不用必须使用global
    print("a=", a)
    a = 10000


t = threading.Thread(target=music)
t.start()
for i in range(2):
    sleep(3)
    print(os.getpid(),"播放:中国心")
t.join()
print("a:", a)
```

13、什么是死锁？

```
死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。
```

14、死锁产生条件？

```
* 互斥条件：指线程使用了互斥方法，使用一个资源时其他线程无法使用。
* 请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求，在获取到新的资源前不会释放自己保持的资源。
* 不剥夺条件：不会受到线程外部的干扰，如系统强制终止线程等。
* 环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，如 T0正在等待一个T1占用的资源；T1正在等待T2占用的资源，……，Tn正在等待已被T0占用的资源。
```

15、如何避免死锁？

```
如何避免死锁
逻辑清晰，不要同时出现上述死锁产生的四个条件
通过测试工程师进行死锁检测
```

16、进程线程的区别联系

```
1. 两者都是多任务编程方式，都能使用计算机多核资源
2. 进程的创建删除消耗的计算机资源比线程多
3. 进程空间独立，数据互不干扰，有专门通信方法；线程使用全局变量通信
4. 一个进程可以有多个分支线程，两者有包含关系
5. 多个线程共享进程资源，在共享资源操作时往往需要同步互斥处理
6. Python线程存在GIL问题，但是进程没有。
```

17、多进程并发模型

```python
"""
基于多进程的tcp网络并发模型
    创建网络套接字用于接收客户端请求
    等待客户端连接
    客户端连接，则创建新的进程具体处理客户端请求
    主进程继续等待其他客户端连接
    如果客户端退出，则销毁对应的进程

重点代码 !!!
"""
from multiprocessing import Process
from socket import *
from signal import *
import sys

# 网络地址
HOST = '0.0.0.0'
PORT = 8888
ADDR = (HOST,PORT)

# 处理客户端事件
def handle(connfd):
    while True:
        data = connfd.recv(1024)
        if not data:
            break
        print(data.decode())
        connfd.send(b'ok')
    connfd.close()

# 搭建并发网络
def main():
    # 创建tcp套接字
    sock = socket()
    sock.bind(ADDR)
    sock.listen(5)

    print("Listen the port %d"%PORT)
    signal(SIGCHLD,SIG_IGN) # 处理僵尸进程

    # 循环等待客户端链接
    while True:
        try:
            connfd,addr = sock.accept()
            print("Connect from",addr)
        except KeyboardInterrupt:
            sys.exit("服务结束")

        # 为连接进来的客户端创建新的进程
        p = Process(target=handle,args=(connfd,))
        p.daemon = True # 子进程随父进程退出
        p.start()

if __name__ == '__main__':
    main()
```

18、多线程并发模型

```python
"""
基于多线程的tcp并发模型

重点代码 !!
"""

from threading import Thread
from socket import *
import sys

# 网络地址
HOST = '0.0.0.0'
PORT = 8888
ADDR = (HOST,PORT)

# 类用于处理客户端的事件
class MyThread(Thread):
    def __init__(self,connfd):
        # 客户端链接套接字设置为属性
        self.connfd = connfd
        super().__init__()

    # 处理客户端事件
    def run(self):
        while True:
            data = self.connfd.recv(1024)
            if not data:
                break
            print(data.decode())
            self.connfd.send(b'ok')
        self.connfd.close()

# 搭建并发网络
def main():
    # 创建tcp套接字
    sock = socket()
    sock.bind(ADDR)
    sock.listen(5)

    print("Listen the port %d"%PORT)

    # 循环等待客户端链接
    while True:
        try:
            connfd,addr = sock.accept()
            print("Connect from",addr)
        except KeyboardInterrupt:
            sys.exit("服务结束")

        # 为连接进来的客户端创建新的线程
        t = MyThread(connfd)
        t.setDaemon(True)
        t.start()

if __name__ == '__main__':
    main()
```