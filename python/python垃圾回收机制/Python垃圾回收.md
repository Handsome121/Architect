# **Python垃圾回收**

- 引用计数器
- 标记清除
- 分代回收
- 缓存机制
- Python的C源码

## 1.引用计数器

### **1.1  环状双向链表refchain**

在python程序中创建的任何对象都会放在refchain中

```python
name = "小马哥"
age = 18
list=[1,2,3,4]
```

```python
内部会创建一些数据【上一个对象，下一个对象，类型，引用个数】
name = "xiaomage"
new = name
"xiaomage"引用计数为2

内部会创建一些数据【上一个对象，下一个对象，类型，引用个数，val=18】
age = 18

内部会创建一些数据【上一个对象，下一个对象，类型，引用个数，items=元素，元素个数】
list=[1,2,3,4]

```

在C源码中如何体现每个对象具有相同的值，PyObject结构体(4个值)

有多个元素组成的对象，PyObject结构体外加obsize

![IMG_0114](.\IMG_0114.JPG)

### 1.2 类型封装结构体

![IMG_0115](.\IMG_0115.JPG)

```python
data = 0.12

内部会创建：
	_ob_next = refchain中的上一个对象
	_ob_prev = refchain中的下一个对象
	_ob_refcnt = 1
	ob_type = float
	ob_fval = 0.12
```

### 1.3 引用计数器

```python
v1 = 3.14
v2 = 999
v3 = (1,2,3)
```

当python程序运行时，会根据数据类型的不同找到其对应的结构体，根据结构体中的字段来进行创建相关的数据，然后将对象添加到refchain双向链表中

在C源码中有两个关键的结构体：PyObject,PyVarObject
每个对象中有_ob_refcnt就是引用计数器，值默认是1，当有其他变量引用这个对象时，引用计数器值发生变化

- 引用

  ```
  a = 9999
  b = a
  ```

  

- 删除引用

  ```
  a = 9999
  b = a
  del b #b变量删除，b对应对象引用计数器-1
  del a #a变量删除，a对应对象引用计数器-1
  
  # 当一个对象的引用计数器为0时。意味着没人引用这个对象，这个对象就是垃圾，垃圾回收
  # 回收：1.对象从refchain链表中移除2.将对象销毁，将内存归还给系统 
  ```

### 1、4 循环引用&交叉感染

```
v1 = [11,22,33] # refchain中创建一个列表对象，由于v1=对象，所以列表对象引用计数器为1
v2 = [44,55,66] # refchain中创建一个列表对象，由于v2=对象，所以列表对象引用计数器为1
v1.append(v2) # 把v2追加到v1中，则v2对应的[44,55,66]对象的引用计数器加1
v2.append(v1) # 把v1追加到v2中，则v1对应的[11,22,33]对象的引用计数器加1

del v1 # 引用计数器减1，此时v1已经被删除，没有任何对象指向这个列表， 在代码中已经变为不可用，但[11,22,33]的引用计数器仍为1，不能被回收，继续占用内存
del v2 # 引用计数器减1，此时v2已经被删除，没有任何对象指向这个列表，在代码中已经变为不可用，但[44,55,66]的引用计数器仍为1，不能被回收，继续占用内存

所以就出现了这两个列表会一直常驻在内存中，永远不被销毁，如果这种代码越来越多的话就会导致程序一直在运行，内存一直在被消耗，内存满了就出现爆栈，程序后重启正常。这就是垃圾数据循环引用导致的数据对象没有被及时的销毁，内存没有被及时释放掉的缘故，导致内存泄漏
```

## 2、标记清除

目的：为了解决引用计数器循环引用的不足

实现：在python底层，再维护一个链表，这个链表中专门放那些可能存在循环引用的对象（列表，字典，集合，可以存入其他对象，可变对象）

![](.\image-20200914115621467.png)

在python内部，某种情况下触发，回去扫描“可能存在循环引用的链表中的每个元素/每个子元素（你中有我，我中有你，就是存在循环引用）”检查是否有循环引用，如果有，让双方的引用计数器各自减1，如果是0则垃圾回收，只有这样才能解除循环引用造成的内存泄漏

问题：

- 什么时候扫描？
- 可能存在循环引用的链表扫描代价大，每次扫描耗时比较久。

## 3、分代回收

![](.\无标题.png)

将可能存在循环引用的对象维护成三个链表，分别叫

- 0代：0代中对象个数达到700个扫描一次

- 1代：0代扫描10次，1代扫描一次

- 2代：1代扫描10次，2代扫描一次

  

每次创建对象会往0代链表中存储，数量达到700个会扫描一次，将存在循环引用的对象剔除，不存在引用计数的对象升级存储在1代中，以此类推升级到2代，这样就解决了标记清除存在的问题

## 4、小结

在python中维护了一个refchain的双向环状链表，这个链表中存储程序创建的所有对象，每种类型的对象中都有一个ob_refcnt引用计数器的值，引用的个数+1，-1，最后当引用计数器的值为0 时，则会进行垃圾回收（对象销毁，refchain中移除）。

但是，在python中对于可以有多个元素组成的对象，可能还会存在循环引用的问题，为了解决这一个问题，python有引入了标记清除和分代回收，在其内部维护4个链表：

- refchain
- 2代 1代扫描10次
- 1代 0代扫描10次
- 0代 对象存储数量达到700个

在源码的内部，当达到各自的阈值时，就会触发扫描链表进行标记清除的动作（有循环各自-1）

但是，源码内部再上述的流程中提出了优化机制

## 5、缓存机制

### 5、1 池（int,str）

为了避免重复创建和销毁一些常见对象，于是就有了维护池

```python
# 启动解释器时，python内部会帮我们创建：-5...256，这些整数组成小数据池，小数据池内存地址是一样的，池中的数据引用计数器值初始化为1
v1 = 1 # 内部不会开辟内存，直接去池中获取
v2 = 2 # 内部不会开辟内存，直接去池中获取
v3 = 2 # 内部不会开辟内存，直接去池中获取
v4 = 257 # 开辟内存
```

## 5.2、free_list（float/list/tuple/dict）

当一个对象的引用计数器为0 时，按理说应该回收，python内部不会直接回收，而是将对象添加到free_list链表中当缓存，以后再去创建对象时，不再重新开辟内存，而是直接使用free_list.

```
v1 = 3.14 # 开辟内存，内部存储结构体中定义那几个值，并存到refchain中
del v1 # refchain中移除，将对象添加到free_list中 ，假设最大存储80个，第81个过来，缓存池满了就会直接销毁

v9 = 999.99 #不会重新开辟内存，而是去free_list中获取对象，对象内部数据进行初始化（值改为999.99，引用计数为0），再放到refchain中
```

