d = {}  #初始化字典  - 初始化了长度为8的数组
d["a"] = 123 # 插入数据  (内部生成一个对象 a-->123)
# 1）hash("a") % 8 = 1 (一定得出一个小于8的值) 根据类似求余的算法(实际是位运算)
# 				的结果(索引) 插入到初始化的长度为8的数组
d["b"] = 456
# 2) 重复1 但是 如果hash("b") % 8 = 1  运算的结果也是1 (学名：哈希碰撞)  - 开放地址法
#  			再次算用上次算出的结果 加上偏移量  hsah(1 + 偏移量) = 3  重复就OK
# 扩容 - 已使用的座位数大于总座位数的三分之二开始扩容 (4倍：5w以下   2倍：当前座位数大于5w)
#		扩容之后  基数(8)发生改变  触发rehash - 重新再来一次 座位重排

# 查找
s = d["b"]
#  hash("b") % 座位长度 = X(索引)  问题 如果在查找b之前把a删了 hash("b") % 座位数 = 1(1是之前a的位置)  删除a类似于伪删除(数据是真的干出去了  但是位置用 dummy占用)  hash("b") 的时候 找到1的位置 发现dummy 知道这里曾经有人(是谁不重要) b当时来的时候应该也遭遇了同样的情况 继续往后找  出入数据时生成的那个对象不仅有key-value 还有 hash值 只有比较后都符合的话才算找到(是因为开放地址法造成的)
# 查找时要维护探测链(必须维护好这个链条不然python不知道该怎么找数据)【数据删除时py给作为进行标记 dummy状态】

# 集合 一样的  只是没有value
# 大量数据 计算查找(hash) 一定要比遍历快 但是字典会有空出来的位置 占内存 同等长度的字典肯定没有列表存的东西多  
# 空间换时间的数据类型