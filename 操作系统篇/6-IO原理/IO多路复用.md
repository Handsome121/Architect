# IO多路复用

1、**什么是文件**

程序员使用I/O最终都逃不过文件这个概念。

在Linux世界中文件是一个很简单的概念，作为程序员我们只需要将其理解为一个N byte的**序列**就可以了：

***b1, b2, b3, b4, ....... bN***

实际上所有的I/O设备都被抽象为了文件这个概念，一切皆文件，Everything is File，磁盘、网络数据、终端，甚至进程间通信工具管道pipe等都被当做文件对待。

所有的I/O操作也都可以通过文件读写来实现，**这一非常优雅的抽象可以让程序员使用一套接口就能对所有外设I/O操作**。

常用的I/O操作接口一般有以下几类：

- 打开文件，open
- 改变读写位置，seek
- 文件读写，read、write
- 关闭文件，close

程序员通过这几个接口几乎可以实现所有I/O操作，这就是文件这个概念的强大之处。

2、**文件描述符**

要想进行I/O读操作，像磁盘数据，我们需要指定一个buff用来装入数据，一般都是这样写的：

```
read(buff);
```

但是这里我们忽略了一个关键问题，那就是虽然我们指定了往哪里写数据，但是我们该从哪里读数据呢？

从上一节中我们知道，通过文件这个概念我们能实现几乎所有I/O操作，**因此这里少的一个主角就是文件**。

那么我们一般都怎样使用文件呢？

同样的，在Linux世界要想使用文件，我们也需要借助一个号码，根据“[弄不懂原则](http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&mid=2247484768&idx=1&sn=049db350af9e5eea5cf3523ceb83f447&chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&scene=21#wechat_redirect)”，这个号码就被称为了文件描述符，**file descriptors**，在Linux世界中鼎鼎大名，其道理和上面那个排队号码一样。

因此，文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。

**有了文件描述符，进程可以对文件一无所知**，比如文件在磁盘的什么位置、加载到内存中又是怎样管理的等等，这些信息统统交由操作系统打理，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。

```
int fd = open(file_name); // 获取文件描述符
read(fd, buff);
```

3、**文件描述符太多了怎么办**

经过了这么多的铺垫，终于要到高性能、高并发这一主题了。

从前几节我们知道，所有I/O操作都可以通过文件样的概念来进行，这当然包括网络通信。

如果你有一个web服务器，当三次握手成功以后，我们会调用accept来获取一个链接，调用该函数我们同样会得到一个文件描述符，通过这个文件描述符就可以处理客户端发送的请求并且把处理结果发送回去。也就是说通过这个描述符我们就可以和客户端进行通信了。

```
// 通过accept获取客户端的文件描述符
int conn_fd = accept(...);
```

server的处理逻辑通常是读取客户端请求数据，然后执行某些特定逻辑：

```
if(read(conn_fd, request_buff) > 0) {
    do_something(request_buff);
}
```

既然我们的主题是高并发，那么**server就不可能只和一个客户端通信**，而是可能会同时和成千上万个客户端进行通信。**这时你需要处理不再是一个描述符这么简单，而是有可能要处理成千上万个描述符**。

为了不让问题一上来就过于复杂，我们先简单化，假设只同时处理两个客户端的请求。

有的同学可能会说，这还不简单，这样写不就行了：

```
if(read(socket_fd1, buff) > 0) { // 处理第一个
    do_something();
}
if(read(socket_fd2, buff) > 0) { // 处理第二个
    do_something();
```

在上一篇《[读取文件时，程序都经历了什么](http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&mid=2247484788&idx=1&sn=e2a084694bedf9b148bbcd5570747add&chksm=fcb9822acbce0b3cba63913ff6de1e37c133b878f02035bc816f7f2ec8423d908bd8560d3605&scene=21#wechat_redirect)》中我们讨论过这是非常典型的阻塞式I/O，如果此时没有数据可读那么进程会被阻塞而暂停运行，这时我们就无法处理第二个请求了，即使第二个请求的数据已经就位，这也就意味着处理某一个客户端时由于进程被阻塞导致剩下的所有其它客户端必须**等待**，在同时处理几万客户端的server上，这显然是不能容忍的。

聪明的你一定会想到使用多线程，为每个客户端请求开启一个线程，这样一个客户端被阻塞就不会影响到处理其它客户端的线程了，注意，既然是高并发，那么我们要为成千上万个请求开启成千上万个线程吗，大量创建销毁线程会严重影响系统性能。

那么这个问题该怎么解决呢？

**这里的关键点在于，我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的**，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。

因此要优雅的解决这个问题，就要从其它角度来思考这个问题了。

4、**不要打电话给我，有需要我会打给你**

大家生活中肯定会接到过推销电话，而且不止一个，一天下来接上十个八个推销电话你的身体会被掏空的。

这个场景的关键点在于打电话的人并不知道你是不是要买东西，只能来一遍遍问你，因此一种更好的策略是不要让他们打电话给你，记下他们的电话，有需要的话打给他们，这样推销员就不会一遍一遍的来烦你了(虽然现实生活中这并不可能)。

在这个例子中，你，就好比内核，推销者就好比应用程序，电话号码就好比文件描述符，和你用电话沟通就好比I/O。

现在你应该明白了吧，处理多个文件描述符的更好方法其实就存在于推销电话中。

因此相比上一节中我们通过I/O接口**主动**问内核这些文件描述符对应的外设是不是已经就绪了，一种更好的方法是，我们把这些感兴趣的文件描述符一股脑扔给内核，并霸气的告诉内核：“**我这里有1万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理**”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？。。。”

这样应用程序就**从“繁忙”的主动变为了清闲的被动**，**反正文件描述可读可写了内核会通知我**，能偷懒我才不要那么勤奋。

这是一种更加高效的I/O处理机制，**现在我们可以一次处理多路I/O了**，为这种机制起一个名字吧，再次祭出“[弄不懂原则](http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&mid=2247484768&idx=1&sn=049db350af9e5eea5cf3523ceb83f447&chksm=fcb9823ecbce0b28ca28d021e68c78138cde4a1b86ea7209c0c667d3d544d223d8b2aecbccec&scene=21#wechat_redirect)”，就叫I/O多路复用吧，这就是 I/O multiplexing。

5、**I/O多路复用**

multiplexing一词其实多用于通信领域，为了充分利用通信线路，希望在一个信道中传输多路信号，要想在一个信道中传输多路信号就需要把这多路信号结合为一路，将多路信号组合成一个信号的设备被称为multiplexer，显然接收方接收到这一路组合后的信号后要恢复原先的多路信号，这个设备被称为demultiplexer

回到我们的主题

所谓I/O多路复用指的是这样一个过程：

\1. 我们拿到了一堆文件描述符(不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)

\2. 通过调用**某个函数**告诉内核：“**这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行I/O读写操作的时候你再返回**”

\3. 当调用的这个函数返回后我们就能知道哪些文件描述符可以进行I/O操作了。

也就是说**通过I/O多路复用我们可以同时处理多路I/O**。那么有哪些函数可以用来进行I/O多路复用呢？

在Linux世界中有这样三种机制可以用来进行I/O多路复用：

- select
- poll
- epoll

6、**I/O多路复用三剑客**

本质上select、poll、epoll都是阻塞式I/O，也就是我们常说的同步I/O，原因在于调用这些I/O多路复用函数时如果任何一个需要监视的文件描述符都不可读或者可写那么进程会被阻塞暂停执行，直到有文件描述符可读或者可写才继续运行。

**select：初出茅庐**

在select这种I/O多路复用机制下，我们需要把想监控的文件描述集合通过函数参数的形式告诉select，然后select会将这些文件描述符集合**拷贝**到内核中，我们知道数据拷贝是有性能损耗的，因此为了减少这种数据拷贝带来的性能损耗，Linux内核对集合的大小做了限制，并规定用户监控的文件描述集合不能超过1024个，同时当select返回后**我们仅仅能知道有些文件描述符可以读写了，但是我们不知道是哪一个**，因此程序员必须再遍历一边找到具体是哪个文件描述符可以读写了。

因此，总结下来select有这样几个特点：

- 我能照看的文件描述符数量有限，不能超过1024个
- 用户给我的文件描述符需要拷贝的内核中
- 我只能告诉你有文件描述符满足要求了，但是我不知道是哪个，你自己一个一个去找吧(遍历)

因此我们可以看到，select机制的这些特性在高并发网络服务器动辄几万几十万并发链接的场景下无疑是低效的。

**poll：小有所成**

poll和select是非常相似的，poll相对于select的优化仅仅在于解决了文件描述符不能超过1024个的限制，select和poll都会随着监控的文件描述数量增加而性能下降，因此不适合高并发场景。

**epoll：独步天下**

在select面临的三个问题中，文件描述数量限制已经在poll中解决了，剩下的两个问题呢？

针对拷贝问题，epoll使用的策略是**各个击破**与**共享内存**。

实际上文件描述符集合的变化频率比较低，select和poll频繁的拷贝整个集合，内核都快被烦死了，epoll通过引入epoll_ctl很体贴的做到了只操作那些有变化的文件描述符，同时epoll和内核还成为了好朋友，共享了同一块内存，这块内存中保存的就是那些已经可读或者可写的的文件描述符集合，这样就减少了内核和程序的拷贝开销。

针对需要遍历文件描述符才能知道哪个可读可写这一问题，epoll使用的策略是“当小弟”。

在select和poll机制下，**进程要亲自下场去各个文件描述符上等待**，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。

但epoll就懂事多了，主动找到进程要当小弟替大哥出头。

针对需要遍历文件描述符才能知道哪个可读可写这一问题，epoll使用的策略是“当小弟”。

在select和poll机制下，**进程要亲自下场去各个文件描述符上等待**，任何一个文件描述可读或者可写就唤醒进程，但是进程被唤醒后也是一脸懵逼并不知道到底是哪个文件描述符可读或可写，还要再从头到尾检查一遍。

但epoll就懂事多了，主动找到进程要当小弟替大哥出头。

**总结：**

基于一切皆文件的设计哲学，I/O也可以通过文件的形式实现，高并发场景下要与多个文件交互，这就离不开高效的I/O多路复用技术，本文我们详细讲解了什么是I/O多路复用以及使用方法，这其中以epoll为代表的I/O多路复用(基于事件驱动)技术使用非常广泛，实际上你会发现但凡涉及到高并发、高性能的场景基本上都能见到事件驱动的编程方法实际上在Linux平台，**epoll基本上就是高并发的代名词**。